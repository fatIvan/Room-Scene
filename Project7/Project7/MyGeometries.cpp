//
//  MyGeometries.cpp - Fall 2022
//
//   Sets up and renders 
//     - the ground plane, and
//     - the surface of rotation
//   for the Math 155A project #6.
//


// Use the static library (so glew32.dll is not needed):
#define GLEW_STATIC
#include <GL/glew.h> 
#include <GLFW/glfw3.h>

#include "LinearR3.h"		// Adjust path as needed.
#include "LinearR4.h"		// Adjust path as needed.
#include "MathMisc.h"       // Adjust path as needed

#include "MyGeometries.h"
#include "TextureProj.h"
#include "PhongData.h"
#include "RgbImage.h"
#include "GlGeomCylinder.h"
#include "GlGeomSphere.h"
#include "GlGeomTorus.h"

// **********************************
// Material to underlie a texture map.
// YOU MAY DEFINE A SECOND ONE OF THESE IF YOU WISH
// **********************************
phMaterial materialUnderTexture;

// **************************
// Information for loading textures
// **************************
const int NumTextures = 15;
unsigned int TextureNames[NumTextures];     // Texture names generated by OpenGL
const char* TextureFiles[NumTextures] = {
    "carpet.bmp", //0
    "legs.bmp", //1
    "table1.bmp", //2
    "window.bmp",//3
    "wall.bmp",//4
    "table2.bmp",//5
    "bedsheet.bmp",//6
    "pillow.bmp",//7
    "door.bmp",//8
    "closetS.bmp",//9
    "closetF.bmp",//10
    "quilt.bmp",//11
    "basketball.bmp",//12
    "map.bmp",//13
    "razerb.bmp"//14
};

// *******************************
// For spheres and a cylinder and a torus (Torus is currently not used.)
// *******************************
GlGeomSphere texSphere(100, 100);
GlGeomCylinder texCylinder(4, 4, 4);
GlGeomTorus texTorus(4, 4, 0.75);


// ************************
// General data helping with setting up VAO (Vertex Array Objects)
//    and Vertex Buffer Objects.
// ***********************
const int NumObjects = 30;
const int iFloor = 0;
const int iCircularSurf = 1;
const int iWall = 2;            // RESERVED FOR USE BY 155A PROJECT
const int iWall2 = 3;
const int iWall3 = 4;
const int iBed1 = 5;
const int iBed2 = 6;
const int iBed3 = 7;
const int iBed4 = 8;
const int iBed5 = 9;
const int iBed6 = 10;
const int iTable1_1 = 11;
const int iTable1_2 = 12;
const int iTable1_3 = 13;
const int iTable1_4 = 14;
const int iTable2_1 = 15;
const int iTable2_2 = 16;
const int iTable2_3 = 17;
const int iTable2_4 = 18;
const int iTable2_5 = 19;
const int iWindow = 20;
const int iDoor = 21;
const int iClosetF = 22;
const int iMap = 23;
const int iRazer = 24;
const int iTable1_5 = 25;
const int iTable1_6 = 26;
const int iBed7 = 27;


unsigned int myVBO[NumObjects];  // a Vertex Buffer Object holds an array of data
unsigned int myVAO[NumObjects];  // a Vertex Array Object - holds info about an array of vertex data;
unsigned int myEBO[NumObjects];  // a Element Array Buffer Object - holds an array of elements (vertex indices)

// ********************************************
// This sets up for texture maps. It is called only once
// ********************************************
void SetupForTextures()
{
    // This material goes under the textures.
    // IF YOU WISH, YOU MAY DEFINE MORE THAN ONE OF THESE FOR DIFFERENT GEOMETRIES
    materialUnderTexture.SpecularColor.Set(0.9, 0.9, 0.9);
    materialUnderTexture.AmbientColor.Set(0.3, 0.3, 0.3);
    materialUnderTexture.DiffuseColor.Set(0.7, 0.7, 0.7);       // Increase or decrease to adjust brightness
    materialUnderTexture.SpecularExponent = 40.0;

    // ***********************************************
    // Load texture maps
	// ***********************************************
    RgbImage texMap;

    glUseProgram(shaderProgramBitmap);
    glActiveTexture(GL_TEXTURE0);
    glGenTextures(NumTextures, TextureNames);
    for (int i = 0; i < NumTextures; i++) {
        texMap.LoadBmpFile(TextureFiles[i]);            // Read i-th texture from the i-th file.
        glBindTexture(GL_TEXTURE_2D, TextureNames[i]);  // Bind (select) the i-th OpenGL texture

        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);

        // Set best quality filtering.   Also see below for disabling mipmaps.
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);  // Requires that mipmaps be generated (see below)
        // You may also try GL_LINEAR_MIPMAP_NEAREST -- try looking at the wall from a 30 degree angle, and look for sweeping transitions.

        // Store the texture into the OpenGL texture named TextureNames[i]
        int textureWidth = texMap.GetNumCols();
        int textureHeight = texMap.GetNumRows();
        glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, textureWidth, textureHeight, 0, GL_RGB, GL_UNSIGNED_BYTE, texMap.ImageData());
 #if 1
        // Use mipmaps  (Best!)
        glGenerateMipmap(GL_TEXTURE_2D);
#else
        // Don't use mipmaps.  Try moving away from the brick wall a great distance
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
#endif

    }

    // Make sure that the shaderProgramBitmap uses the GL_TEXTURE_0 texture.
    glUseProgram(shaderProgramBitmap);
    glUniform1i(glGetUniformLocation(shaderProgramBitmap, "theTextureMap"), 0);
    glActiveTexture(GL_TEXTURE0);


}

// **********************
// This sets up geometries needed for 
//   (a) the floor (ground plane)
//   (b) the back wall
//   (c) the circular mesh
//   (d) two spheres
//   (e) one cylinder
//  It is called only once.
//  YOU NEED TO CHANGE THIS ONCE YOU ADD THE TEXTURE COORDINATES TO THE CIRCULAR SURFACE.
// **********************
void MySetupSurfaces() {

    texSphere.InitializeAttribLocations(vertPos_loc, vertNormal_loc, vertTexCoords_loc);
    texCylinder.InitializeAttribLocations(vertPos_loc, vertNormal_loc, vertTexCoords_loc);
    //texTorus.InitializeAttribLocations(vertPos_loc, vertNormal_loc, vertTexCoords_loc);

    // Initialize the VAO's, VBO's and EBO's for the ground plane, the back wall
    // and the surface of rotation. Gives them the "vertPos" location,
    // and the "vertNormal"  and the "vertTexCoords" locations in the shader program.
    // No data is loaded into the VBO's or EBO's for the circular surface until the "Remesh"
    //   routines is called

    glGenVertexArrays(NumObjects, &myVAO[0]);
    glGenBuffers(NumObjects, &myVBO[0]);
    glGenBuffers(NumObjects, &myEBO[0]);

    // For the Floor:
    // Allocate the needed Vertex Array Objects (VAO's),
    //      Vertex Buffer Objects (VBO's) and Element Array Buffer Objects (EBO's)
    // Since the floor has only four vertices.  Each vertex stores its
    //    position, its normal (0,1,0) and its (s,t)-coordinates.
    // YOU DO NOT NEED TO REMESH THE FLOOR (OR THE BACK WALL) SINCE WE USE PHONG INTERPOLATION
    float floorVerts[] = {
        // Position              // Normal                  // Texture coordinates
        -5.0f, 0.0f, -5.0f,      0.0f, 1.0f, 0.0f,          0.0f, 1.0f,         // Back left
         5.0f, 0.0f, -5.0f,      0.0f, 1.0f, 0.0f,          1.0f, 1.0f,         // Back right
         5.0f, 0.0f,  5.0f,      0.0f, 1.0f, 0.0f,          1.0f, 0.0f,         // Front right
        -5.0f, 0.0f,  5.0f,      0.0f, 1.0f, 0.0f,          0.0f, 0.0f,         // Front left
    };

    unsigned int floorElts[] = { 0, 3, 1, 2 };
    glBindBuffer(GL_ARRAY_BUFFER, myVBO[iFloor]);
    glBindVertexArray(myVAO[iFloor]);
    glBufferData(GL_ARRAY_BUFFER, sizeof(floorVerts), floorVerts, GL_STATIC_DRAW);
    glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);	   // Vertex positions in the VBO
    glEnableVertexAttribArray(vertPos_loc);									// Enable the stored vertices
    glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));	// Vertex normals in the VBO
    glEnableVertexAttribArray(vertNormal_loc);									// Enable the stored vertices
    glVertexAttribPointer(vertTexCoords_loc, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));	// Vertex texture coordinates in the VBO
    glEnableVertexAttribArray(vertTexCoords_loc);									// Enable the stored vertices
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[iFloor]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(floorElts), floorElts, GL_STATIC_DRAW);

    //unsigned int floorElts[] = { 0, 3, 1, 2 };
    //glBindBuffer(GL_ARRAY_BUFFER, myVBO[iFloor]);
    //glBindVertexArray(myVAO[iFloor]);
    //glBufferData(GL_ARRAY_BUFFER, sizeof(floorVerts), floorVerts, GL_STATIC_DRAW);
    //glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);	   // Vertex positions in the VBO
    //glEnableVertexAttribArray(vertPos_loc);									// Enable the stored vertices
    //glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3*sizeof(float)));	// Vertex normals in the VBO
    //glEnableVertexAttribArray(vertNormal_loc);									// Enable the stored vertices
    //glVertexAttribPointer(vertTexCoords_loc, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));	// Vertex texture coordinates in the VBO
    //glEnableVertexAttribArray(vertTexCoords_loc);									// Enable the stored vertices
    //glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[iFloor]);
    //glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(floorElts), floorElts, GL_STATIC_DRAW);

    // For the circular surface:
    // Allocate the needed VAO, VBO< EBO
    // The normal vectors is specified separately for each vertex. (It is not a generic attribute.)
    // YOU MUST MODIFY THIS TO (A) USE STRIDES OF 8 *sizeof(float), (B) COMMENT IN THE LINES FOR vertTexCoords 
    glBindVertexArray(myVAO[iCircularSurf]);
    glBindBuffer(GL_ARRAY_BUFFER, myVBO[iCircularSurf]);
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[iCircularSurf]);
    glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);	// Store vertices in the VBO
    glEnableVertexAttribArray(vertPos_loc);									// Enable the stored vertices
    glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float))); // Store normals in the VBO
    glEnableVertexAttribArray(vertNormal_loc);                                 // Enabled the stored normals (so they are not generic)
    // ONCE YOU HAVE TEXTURE COORDINATES WORKING FOR THE CIRCULAR SURFACE,
    //   PUT THE NEXT TWO LINES BACK IN, AND CHANGE THE STRIDE FACTOR TO "8" IN THE PREVIOUS CALLS TO glVertexAttribPointer.
    glVertexAttribPointer(vertTexCoords_loc, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));	// Vertex texture coordinates in the VBO
    glEnableVertexAttribArray(vertTexCoords_loc);									// Enable the stored vertices

    // No data has been loaded into the VBO's for the circular surface yet.
    // This is done by the "SamsRemeshCircularSurf" routine.

    //SamsRemeshCircularSurf();

    // FOR THE BACK WALL: ADD YOUR OWN CODE!! 
    // IT WILL BE SIMILAR TO THE FLOOR ABOVE.
    // YOU DO NOT NEED TO REMESH THE BACK WALL - ONE RECTANGLE (TWO TRIANGLES) IS ENOUGH

    float wallVerts[] = {
        // Position              // Normal                  // Texture coordinates
        -5.0f, 5.0f, -5.0f,      0.0f, 0.0f, 1.0f,          0.0f, 1.0f,         // Back left
         5.0f, 5.0f, -5.0f,      0.0f, 0.0f, 1.0f,          1.0f, 1.0f,         // Back right
         5.0f, 0.0f, -5.0f,      0.0f, 0.0f, 1.0f,          1.0f, 0.0f,         // Front right
        -5.0f, 0.0f, -5.0f,      0.0f, 0.0f, 1.0f,          0.0f, 0.0f,         // Front left
    };
    unsigned int wallElts[] = { 0, 3, 1, 2 };
    glBindBuffer(GL_ARRAY_BUFFER, myVBO[iWall]);
    glBindVertexArray(myVAO[iWall]);
    glBufferData(GL_ARRAY_BUFFER, sizeof(wallVerts), wallVerts, GL_STATIC_DRAW);
    glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);	   // Vertex positions in the VBO
    glEnableVertexAttribArray(vertPos_loc);									// Enable the stored vertices
    glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));	// Vertex normals in the VBO
    glEnableVertexAttribArray(vertNormal_loc);									// Enable the stored vertices
    glVertexAttribPointer(vertTexCoords_loc, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));	// Vertex texture coordinates in the VBO
    glEnableVertexAttribArray(vertTexCoords_loc);									// Enable the stored vertices
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[iWall]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(wallElts), wallElts, GL_STATIC_DRAW);





    float mapVerts[] = {
        // Position              // Normal                  // Texture coordinates
        -2.0f, 2.0f, -4.99f,      0.0f, 0.0f, 1.0f,          0.0f, 0.0f,         // Back left
         2.0f, 2.0f, -4.99f,      0.0f, 0.0f, 1.0f,          1.0f, 0.0f,         // Back right
        -2.0f, 4.5f, -4.99f,      0.0f, 0.0f, 1.0f,          0.0f, 1.0f,         // Front right
         2.0f, 4.5f, -4.99f,      0.0f, 0.0f, 1.0f,          1.0f, 1.0f,         // Front left
    };
    unsigned int mapElts[] = { 0, 1,2,3 };
    glBindBuffer(GL_ARRAY_BUFFER, myVBO[iMap]);
    glBindVertexArray(myVAO[iMap]);
    glBufferData(GL_ARRAY_BUFFER, sizeof(mapVerts), mapVerts, GL_STATIC_DRAW);
    glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);	   // Vertex positions in the VBO
    glEnableVertexAttribArray(vertPos_loc);									// Enable the stored vertices
    glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));	// Vertex normals in the VBO
    glEnableVertexAttribArray(vertNormal_loc);									// Enable the stored vertices
    glVertexAttribPointer(vertTexCoords_loc, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));	// Vertex texture coordinates in the VBO
    glEnableVertexAttribArray(vertTexCoords_loc);									// Enable the stored vertices
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[iMap]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(mapElts), mapElts, GL_STATIC_DRAW);








    float windowVerts[] = {
        -4.99f, 3.5f, 2.0f,      1.0f, 0.0f, 0.0f,          0.0f, 1.0f,         // Back left
        -4.99f, 3.5f, -2.0f,      1.0f, 0.0f, 0.0f,          1.0f, 1.0f,         // Back right
        -4.99f, 1.5f, -2.0f,      1.0f, 0.0f, 0.0f,          1.0f, 0.0f,         // Front right
        -4.99f, 1.5f, 2.0f,      1.0f, 0.0f, 0.0f,          0.0f, 0.0f,         // Front left
    };

    unsigned int windowElts[] = { 3, 2, 0, 1 };
    glBindBuffer(GL_ARRAY_BUFFER, myVBO[iWindow]);
    glBindVertexArray(myVAO[iWindow]);
    glBufferData(GL_ARRAY_BUFFER, sizeof(windowVerts), windowVerts, GL_STATIC_DRAW);
    glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);	   // Vertex positions in the VBO
    glEnableVertexAttribArray(vertPos_loc);									// Enable the stored vertices
    glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));	// Vertex normals in the VBO
    glEnableVertexAttribArray(vertNormal_loc);									// Enable the stored vertices
    glVertexAttribPointer(vertTexCoords_loc, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));	// Vertex texture coordinates in the VBO
    glEnableVertexAttribArray(vertTexCoords_loc);									// Enable the stored vertices
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[iWindow]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(windowElts), windowElts, GL_STATIC_DRAW);


    float leftWallVerts[] = {
        // Position              // Normal                  // Texture coordinates
        -5.0f, 5.0f, 5.0f,      1.0f, 0.0f, 0.0f,          0.0f, 1.0f,         // top left
        -5.0f, 5.0f, -5.0f,      1.0f, 0.0f, 0.0f,          1.0f, 1.0f,         // top right
        -5.0f, 0.0f, -5.0f,      1.0f, 0.0f, 0.0f,          1.0f, 0.0f,         // bot right
        -5.0f, 0.0f, 5.0f,      1.0f, 0.0f, 0.0f,          0.0f, 0.0f,         // bot left


    };
    unsigned int leftWallElts[] = { 3, 2, 0, 1 };
    glBindBuffer(GL_ARRAY_BUFFER, myVBO[iWall2]);
    glBindVertexArray(myVAO[iWall2]);
    glBufferData(GL_ARRAY_BUFFER, sizeof(leftWallVerts), leftWallVerts, GL_STATIC_DRAW);
    glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);	   // Vertex positions in the VBO
    glEnableVertexAttribArray(vertPos_loc);									// Enable the stored vertices
    glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));	// Vertex normals in the VBO
    glEnableVertexAttribArray(vertNormal_loc);									// Enable the stored vertices
    glVertexAttribPointer(vertTexCoords_loc, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));	// Vertex texture coordinates in the VBO
    glEnableVertexAttribArray(vertTexCoords_loc);									// Enable the stored vertices
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[iWall2]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(leftWallElts), leftWallElts, GL_STATIC_DRAW);

    float rightWallVerts[] = {
        // Position              // Normal                  // Texture coordinates
         5.0f, 5.0f, -5.0f,      -1.0f, 0.0f, 0.0f,          0.0f, 1.0f,         // Back left
         5.0f, 5.0f, 5.0f,       -1.0f, 0.0f, 0.0f,          1.0f, 1.0f,         // Back right
         5.0f, 0.0f, 5.0f,       -1.0f, 0.0f, 0.0f,          1.0f, 0.0f,         // Front right
         5.0f, 0.0f, -5.0f,      -1.0f, 0.0f, 0.0f,          0.0f, 0.0f,         // Front left
    };
    unsigned int rightWallElts[] = { 0, 3, 1, 2 };
    glBindBuffer(GL_ARRAY_BUFFER, myVBO[iWall3]); //need to be changed
    glBindVertexArray(myVAO[iWall3]); //need to be changed
    glBufferData(GL_ARRAY_BUFFER, sizeof(rightWallVerts), rightWallVerts, GL_STATIC_DRAW);
    glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);	   // Vertex positions in the VBO
    glEnableVertexAttribArray(vertPos_loc);									// Enable the stored vertices
    glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));	// Vertex normals in the VBO
    glEnableVertexAttribArray(vertNormal_loc);									// Enable the stored vertices
    glVertexAttribPointer(vertTexCoords_loc, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));	// Vertex texture coordinates in the VBO
    glEnableVertexAttribArray(vertTexCoords_loc);									// Enable the stored vertices
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[iWall3]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(rightWallElts), rightWallElts, GL_STATIC_DRAW);



    //right door verts
    float doorVerts[] = {
        // Position              // Normal                  // Texture coordinates
         4.9f, 0.0f, 1.0f,      -1.0f, 0.0f, 0.0f,          0.0f, 0.0f,         // Back left
         4.9f, 0.0f, 3.0f,       -1.0f, 0.0f, 0.0f,          1.0f, 0.0f,         // Back right
         4.9f, 4.0f, 1.0f,       -1.0f, 0.0f, 0.0f,          0.0f, 1.0f,         // Front right
         4.9f, 4.0f, 3.0f,      -1.0f, 0.0f, 0.0f,          1.0f, 1.0f,         // Front left
    };
    unsigned int doorElts[] = { 0, 1, 2, 3 };
    glBindBuffer(GL_ARRAY_BUFFER, myVBO[iDoor]); //need to be changed
    glBindVertexArray(myVAO[iDoor]); //need to be changed
    glBufferData(GL_ARRAY_BUFFER, sizeof(doorVerts), doorVerts, GL_STATIC_DRAW);
    glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);	   // Vertex positions in the VBO
    glEnableVertexAttribArray(vertPos_loc);									// Enable the stored vertices
    glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));	// Vertex normals in the VBO
    glEnableVertexAttribArray(vertNormal_loc);									// Enable the stored vertices
    glVertexAttribPointer(vertTexCoords_loc, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));	// Vertex texture coordinates in the VBO
    glEnableVertexAttribArray(vertTexCoords_loc);									// Enable the stored vertices
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[iDoor]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(doorElts), doorElts, GL_STATIC_DRAW);



    //laptop

    float laptopVerts[] = {
        // Position              // Normal                  // Texture coordinates
         -4.2f, 2.6f + 0.25f, -3.6f,      0.0f, 1.0f, 0.0f,          0.0f, 0.0f,         // Back left
         -2.8f, 2.6f + 0.25f, -3.6f,       0.0f, 1.0f, 0.0f,          1.0f, 0.0f,         // Back right
         -4.2f, 2.6f + 0.25f, -4.4f,       0.0f, 1.0f, 0.0f,          0.0f, 1.0f,         // Front right
         -2.8f, 2.6f + 0.25f, -4.4f,      0.0f, 1.0f, 0.0f,          1.0f, 1.0f,         // Front left
    };
    unsigned int laptopElts[] = { 0, 1, 2, 3 };
    glBindBuffer(GL_ARRAY_BUFFER, myVBO[iRazer]); //need to be changed
    glBindVertexArray(myVAO[iRazer]); //need to be changed
    glBufferData(GL_ARRAY_BUFFER, sizeof(laptopVerts), laptopVerts, GL_STATIC_DRAW);
    glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);	   // Vertex positions in the VBO
    glEnableVertexAttribArray(vertPos_loc);									// Enable the stored vertices
    glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));	// Vertex normals in the VBO
    glEnableVertexAttribArray(vertNormal_loc);									// Enable the stored vertices
    glVertexAttribPointer(vertTexCoords_loc, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));	// Vertex texture coordinates in the VBO
    glEnableVertexAttribArray(vertTexCoords_loc);									// Enable the stored vertices
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[iRazer]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(laptopElts), laptopElts, GL_STATIC_DRAW);





    //Bed lies next to window on the left of the scene facing in.\
      
    //TODO: Need a cylinder as pillow

    //Width 3 height 3 mattress texture
    float bedfrontVerts[] = {
    -5.0f, 0.0f, 5.0f,           0.0f, 0.0f,1.0f,        0.0f, 0.0f,       // bed bottom left coordinate
    -2.0f, 0.0f, 5.0f,           0.0f, 0.0f,1.0f,        1.0f, 0.0f,       // bed bottom right coordinate
    -5.0f, 0.5f, 5.0f,           0.0f, 0.0f,1.0f,        0.0f, 1.0f,       // bed top left coordinate
    -2.0f, 0.5f, 5.0f,           0.0f, 0.0f,1.0f,        1.0f, 1.0f,       // bed top right coordinate
    };

    unsigned int bedfrontElts[] = { 0, 1, 2, 3 };
    glBindBuffer(GL_ARRAY_BUFFER, myVBO[iBed1]); //need to be changed
    glBindVertexArray(myVAO[iBed1]); //need to be changed
    glBufferData(GL_ARRAY_BUFFER, sizeof(bedfrontVerts), bedfrontVerts, GL_STATIC_DRAW);
    glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);	   // Vertex positions in the VBO
    glEnableVertexAttribArray(vertPos_loc);									// Enable the stored vertices
    glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));	// Vertex normals in the VBO
    glEnableVertexAttribArray(vertNormal_loc);									// Enable the stored vertices
    glVertexAttribPointer(vertTexCoords_loc, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));	// Vertex texture coordinates in the VBO
    glEnableVertexAttribArray(vertTexCoords_loc);									// Enable the stored vertices
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[iBed1]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(bedfrontElts), bedfrontElts, GL_STATIC_DRAW);


    //Length 5 height 3 bedsheet texture
    float bedrightfeetVerts[] = {
    -2.0f, 0.0f, 4.0f,           1.0f, 0.0f,0.0f,        0.0f, 0.0f,       // bed bottom left coordinate
    -2.0f, 0.0f, 0.0f,           1.0f, 0.0f,0.0f,        1.0f, 0.0f,       // bed bottom right coordinate
    -2.0f, 0.5f, 4.0f,           1.0f, 0.0f,0.0f,        0.0f, 1.0f,       // bed top left coordinate
    -2.0f, 0.5f, 0.0f,           1.0f, 0.0f,0.0f,        1.0f, 1.0f,       // bed top right coordinate
    };

    unsigned int bedrightfeetElts[] = { 0, 1, 2, 3 };
    glBindBuffer(GL_ARRAY_BUFFER, myVBO[iBed2]); //need to be changed
    glBindVertexArray(myVAO[iBed2]); //need to be changed
    glBufferData(GL_ARRAY_BUFFER, sizeof(bedrightfeetVerts), bedrightfeetVerts, GL_STATIC_DRAW);
    glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);	   // Vertex positions in the VBO
    glEnableVertexAttribArray(vertPos_loc);									// Enable the stored vertices
    glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));	// Vertex normals in the VBO
    glEnableVertexAttribArray(vertNormal_loc);									// Enable the stored vertices
    glVertexAttribPointer(vertTexCoords_loc, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));	// Vertex texture coordinates in the VBO
    glEnableVertexAttribArray(vertTexCoords_loc);									// Enable the stored vertices
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[iBed2]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(bedrightfeetElts), bedrightfeetElts, GL_STATIC_DRAW);

    //Length 5 height 3 mattress texture
    float bedrightheadVerts[] = {
    -2.0f, 0.0f, 5.0f,           1.0f, 0.0f,0.0f,        0.0f, 0.0f,       // bed bottom left coordinate
    -2.0f, 0.0f, 4.0f,           1.0f, 0.0f,0.0f,        1.0f, 0.0f,       // bed bottom right coordinate
    -2.0f, 0.5f, 5.0f,           1.0f, 0.0f,0.0f,        0.0f, 1.0f,       // bed top left coordinate
    -2.0f, 0.5f, 4.0f,           1.0f, 0.0f,0.0f,        1.0f, 1.0f,       // bed top right coordinate
    };

    unsigned int bedrightheadElts[] = { 0, 1, 2, 3 };
    glBindBuffer(GL_ARRAY_BUFFER, myVBO[iBed3]); //need to be changed
    glBindVertexArray(myVAO[iBed3]); //need to be changed
    glBufferData(GL_ARRAY_BUFFER, sizeof(bedrightheadVerts), bedrightheadVerts, GL_STATIC_DRAW);
    glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);	   // Vertex positions in the VBO
    glEnableVertexAttribArray(vertPos_loc);									// Enable the stored vertices
    glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));	// Vertex normals in the VBO
    glEnableVertexAttribArray(vertNormal_loc);									// Enable the stored vertices
    glVertexAttribPointer(vertTexCoords_loc, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));	// Vertex texture coordinates in the VBO
    glEnableVertexAttribArray(vertTexCoords_loc);									// Enable the stored vertices
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[iBed3]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(bedrightheadElts), bedrightheadElts, GL_STATIC_DRAW);


    //Length 5 height 3 mattress texture
    float bedleftVerts[] = {
    -5.0f, 0.0f, 0.0f,           -1.0f, 0.0f,0.0f,        0.0f, 0.0f,       // bed bottom left coordinate
    -5.0f, 0.0f, 5.0f,           -1.0f, 0.0f,0.0f,        1.0f, 0.0f,       // bed bottom right coordinate
    -5.0f, 0.5f, 0.0f,           -1.0f, 0.0f,0.0f,        0.0f, 1.0f,       // bed top left coordinate
    -5.0f, 0.5f, 5.0f,           -1.0f, 0.0f,0.0f,        1.0f, 1.0f,       // bed top right coordinate
    };

    unsigned int bedleftElts[] = { 0, 1, 2, 3 };
    glBindBuffer(GL_ARRAY_BUFFER, myVBO[iBed7]); //need to be changed
    glBindVertexArray(myVAO[iBed7]); //need to be changed
    glBufferData(GL_ARRAY_BUFFER, sizeof(bedleftVerts), bedleftVerts, GL_STATIC_DRAW);
    glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);	   // Vertex positions in the VBO
    glEnableVertexAttribArray(vertPos_loc);									// Enable the stored vertices
    glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));	// Vertex normals in the VBO
    glEnableVertexAttribArray(vertNormal_loc);									// Enable the stored vertices
    glVertexAttribPointer(vertTexCoords_loc, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));	// Vertex texture coordinates in the VBO
    glEnableVertexAttribArray(vertTexCoords_loc);									// Enable the stored vertices
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[iBed7]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(bedleftElts), bedleftElts, GL_STATIC_DRAW);
    //Length 5 height 3 bedsheet texture
    float bedbackVerts[] = {
    -2.0f, 0.0f, 0.0f,           0.0f, 0.0f,-1.0f,        0.0f, 0.0f,       // bed bottom left coordinate
    -5.0f, 0.0f, 0.0f,           0.0f, 0.0f,-1.0f,        1.0f, 0.0f,       // bed bottom right coordinate
    -2.0f, 0.5f, 0.0f,           0.0f, 0.0f,-1.0f,        0.0f, 1.0f,       // bed top left coordinate
    -5.0f, 0.5f, 0.0f,           0.0f, 0.0f,-1.0f,        1.0f, 1.0f,       // bed top right coordinate
    };

    unsigned int bedbackElts[] = { 0, 1, 2, 3 };
    glBindBuffer(GL_ARRAY_BUFFER, myVBO[iBed4]); //need to be changed
    glBindVertexArray(myVAO[iBed4]); //need to be changed
    glBufferData(GL_ARRAY_BUFFER, sizeof(bedbackVerts), bedbackVerts, GL_STATIC_DRAW);
    glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);	   // Vertex positions in the VBO
    glEnableVertexAttribArray(vertPos_loc);									// Enable the stored vertices
    glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));	// Vertex normals in the VBO
    glEnableVertexAttribArray(vertNormal_loc);									// Enable the stored vertices
    glVertexAttribPointer(vertTexCoords_loc, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));	// Vertex texture coordinates in the VBO
    glEnableVertexAttribArray(vertTexCoords_loc);									// Enable the stored vertices
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[iBed4]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(bedbackElts), bedbackElts, GL_STATIC_DRAW);

    //Length 5 width 3 bedsheet texture
    float bedtopVerts[] = {
    -2.0f, 0.5f, 4.0f,           0.0f, 1.0f, 0.0f,        0.0f, 0.0f,       // bed bottom left coordinate
    -2.0f, 0.5f, 0.0f,           0.0f, 1.0f, 0.0f,        1.0f, 0.0f,       // bed bottom right coordinate
    -5.0f, 0.5f, 4.0f,           0.0f, 1.0f, 0.0f,        0.0f, 1.0f,       // bed top left coordinate
    -5.0f, 0.5f, 0.0f,           0.0f, 1.0f, 0.0f,        1.0f, 1.0f,       // bed top right coordinate
    };

    unsigned int bedtopElts[] = { 0, 1, 2, 3 };
    glBindBuffer(GL_ARRAY_BUFFER, myVBO[iBed5]); //need to be changed
    glBindVertexArray(myVAO[iBed5]); //need to be changed
    glBufferData(GL_ARRAY_BUFFER, sizeof(bedtopVerts), bedtopVerts, GL_STATIC_DRAW);
    glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);	   // Vertex positions in the VBO
    glEnableVertexAttribArray(vertPos_loc);									// Enable the stored vertices
    glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));	// Vertex normals in the VBO
    glEnableVertexAttribArray(vertNormal_loc);									// Enable the stored vertices
    glVertexAttribPointer(vertTexCoords_loc, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));	// Vertex texture coordinates in the VBO
    glEnableVertexAttribArray(vertTexCoords_loc);									// Enable the stored vertices
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[iBed5]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(bedtopElts), bedtopElts, GL_STATIC_DRAW);

    //Length 5 width 3 mattress texture
    float bedtopheadVerts[] = {
    -2.0f, 0.5f, 5.0f,           0.0f, 1.0f, 0.0f,        0.0f, 0.0f,       // bed bottom left coordinate
    -2.0f, 0.5f, 4.0f,           0.0f, 1.0f, 0.0f,        1.0f, 0.0f,       // bed bottom right coordinate
    -5.0f, 0.5f, 5.0f,           0.0f, 1.0f, 0.0f,        0.0f, 1.0f,       // bed top left coordinate
    -5.0f, 0.5f, 4.0f,           0.0f, 1.0f, 0.0f,        1.0f, 1.0f,       // bed top right coordinate
    };

    unsigned int bedtopheadElts[] = { 0, 1, 2, 3 };
    glBindBuffer(GL_ARRAY_BUFFER, myVBO[iBed6]); //need to be changed
    glBindVertexArray(myVAO[iBed6]); //need to be changed
    glBufferData(GL_ARRAY_BUFFER, sizeof(bedtopheadVerts), bedtopheadVerts, GL_STATIC_DRAW);
    glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);	   // Vertex positions in the VBO
    glEnableVertexAttribArray(vertPos_loc);									// Enable the stored vertices
    glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));	// Vertex normals in the VBO
    glEnableVertexAttribArray(vertNormal_loc);									// Enable the stored vertices
    glVertexAttribPointer(vertTexCoords_loc, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));	// Vertex texture coordinates in the VBO
    glEnableVertexAttribArray(vertTexCoords_loc);									// Enable the stored vertices
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[iBed6]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(bedtopheadElts), bedtopheadElts, GL_STATIC_DRAW);




    // table 1 length 3 width 2 thick 0.5\

    // table legs 4 cylinders, feet 2 cylinders





    float table1frontVerts[] = {
    -5.0f, 2.5f, -3.0f,           0.0f, 0.0f, 1.0f,        0.0f, 0.0f,       // bottom left coordinate
    -2.0f, 2.5f, -3.0f,           0.0f, 0.0f, 1.0f,        1.0f, 0.0f,       // bottom right coordinate
    -5.0f, 2.6f, -3.0f,           0.0f, 0.0f, 1.0f,        0.0f, 1.0f,       // top left coordinate
    -2.0f, 2.6f, -3.0f,           0.0f, 0.0f, 1.0f,        1.0f, 1.0f,       // top right coordinate
    };

    unsigned int table1frontElts[] = { 0, 1, 2, 3 };
    glBindBuffer(GL_ARRAY_BUFFER, myVBO[iTable1_1]); //need to be changed
    glBindVertexArray(myVAO[iTable1_1]); //need to be changed
    glBufferData(GL_ARRAY_BUFFER, sizeof(table1frontVerts), table1frontVerts, GL_STATIC_DRAW);
    glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);	   // Vertex positions in the VBO
    glEnableVertexAttribArray(vertPos_loc);									// Enable the stored vertices
    glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));	// Vertex normals in the VBO
    glEnableVertexAttribArray(vertNormal_loc);									// Enable the stored vertices
    glVertexAttribPointer(vertTexCoords_loc, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));	// Vertex texture coordinates in the VBO
    glEnableVertexAttribArray(vertTexCoords_loc);									// Enable the stored vertices
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[iTable1_1]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(table1frontElts), table1frontElts, GL_STATIC_DRAW);

    float table1rightVerts[] = {
    -2.0f, 2.5f, -3.0f,           1.0f, 0.0f, 0.0f,        0.0f, 0.0f,       // bottom left coordinate
    -2.0f, 2.5f, -5.0f,           1.0f, 0.0f, 0.0f,        1.0f, 0.0f,       // bottom right coordinate
    -2.0f, 2.6f, -3.0f,           1.0f, 0.0f, 0.0f,        0.0f, 1.0f,       // top left coordinate
    -2.0f, 2.6f, -5.0f,           1.0f, 0.0f, 0.0f,        1.0f, 1.0f,       // top right coordinate
    };

    unsigned int table1rightElts[] = { 0, 1, 2, 3 };
    glBindBuffer(GL_ARRAY_BUFFER, myVBO[iTable1_2]); //need to be changed
    glBindVertexArray(myVAO[iTable1_2]); //need to be changed
    glBufferData(GL_ARRAY_BUFFER, sizeof(table1rightVerts), table1rightVerts, GL_STATIC_DRAW);
    glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);	   // Vertex positions in the VBO
    glEnableVertexAttribArray(vertPos_loc);									// Enable the stored vertices
    glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));	// Vertex normals in the VBO
    glEnableVertexAttribArray(vertNormal_loc);									// Enable the stored vertices
    glVertexAttribPointer(vertTexCoords_loc, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));	// Vertex texture coordinates in the VBO
    glEnableVertexAttribArray(vertTexCoords_loc);									// Enable the stored vertices
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[iTable1_2]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(table1rightElts), table1rightElts, GL_STATIC_DRAW);

    float tablebackVerts[] = {
    -2.0f, 2.5f, -5.0f,           0.0f, 0.0f, -1.0f,        0.0f, 0.0f,       // bottom left coordinate
    -5.0f, 2.5f, -5.0f,           0.0f, 0.0f, -1.0f,        1.0f, 0.0f,       // bottom right coordinate
    -2.0f, 2.6f, -5.0f,           0.0f, 0.0f, -1.0f,        0.0f, 1.0f,       // top left coordinate
    -5.0f, 2.6f, -5.0f,           0.0f, 0.0f, -1.0f,        1.0f, 1.0f,       // top right coordinate
    };

    unsigned int table1backElts[] = { 0, 1, 2, 3 };
    glBindBuffer(GL_ARRAY_BUFFER, myVBO[iTable1_5]); //need to be changed
    glBindVertexArray(myVAO[iTable1_5]); //need to be changed
    glBufferData(GL_ARRAY_BUFFER, sizeof(tablebackVerts), tablebackVerts, GL_STATIC_DRAW);
    glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);	   // Vertex positions in the VBO
    glEnableVertexAttribArray(vertPos_loc);									// Enable the stored vertices
    glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));	// Vertex normals in the VBO
    glEnableVertexAttribArray(vertNormal_loc);									// Enable the stored vertices
    glVertexAttribPointer(vertTexCoords_loc, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));	// Vertex texture coordinates in the VBO
    glEnableVertexAttribArray(vertTexCoords_loc);									// Enable the stored vertices
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[iTable1_5]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(table1backElts), table1backElts, GL_STATIC_DRAW);

    float table1lefttVerts[] = {
    -5.0f, 2.5f, -5.0f,           -1.0f, 0.0f, 0.0f,        0.0f, 0.0f,       // bottom left coordinate
    -5.0f, 2.5f, -3.0f,           -1.0f, 0.0f, 0.0f,        1.0f, 0.0f,       // bottom right coordinate
    -5.0f, 2.6f, -5.0f,           -1.0f, 0.0f, 0.0f,        0.0f, 1.0f,       // top left coordinate
    -5.0f, 2.6f, -3.0f,           -1.0f, 0.0f, 0.0f,        1.0f, 1.0f,       // top right coordinate
    };

    unsigned int table1leftElts[] = { 0, 1, 2, 3 };
    glBindBuffer(GL_ARRAY_BUFFER, myVBO[iTable1_6]); //need to be changed
    glBindVertexArray(myVAO[iTable1_6]); //need to be changed
    glBufferData(GL_ARRAY_BUFFER, sizeof(table1lefttVerts), table1lefttVerts, GL_STATIC_DRAW);
    glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);	   // Vertex positions in the VBO
    glEnableVertexAttribArray(vertPos_loc);									// Enable the stored vertices
    glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));	// Vertex normals in the VBO
    glEnableVertexAttribArray(vertNormal_loc);									// Enable the stored vertices
    glVertexAttribPointer(vertTexCoords_loc, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));	// Vertex texture coordinates in the VBO
    glEnableVertexAttribArray(vertTexCoords_loc);									// Enable the stored vertices
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[iTable1_6]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(table1leftElts), table1leftElts, GL_STATIC_DRAW);



















    float table1topVerts[] = {
    -5.0f, 2.6f, -3.0f,           0.0f, 1.0f, 0.0f,        0.0f, 0.0f,       // bottom left coordinate
    -2.0f, 2.6f, -3.0f,           0.0f, 1.0f, 0.0f,        1.0f, 0.0f,       // bottom right coordinate
    -5.0f, 2.6f, -5.0f,           0.0f, 1.0f, 0.0f,        0.0f, 1.0f,       // top left coordinate
    -2.0f, 2.6f, -5.0f,           0.0f, 1.0f, 0.0f,        1.0f, 1.0f,       // top right coordinate
    };

    unsigned int table1topElts[] = { 0, 1, 2, 3 };
    glBindBuffer(GL_ARRAY_BUFFER, myVBO[iTable1_3]); //need to be changed
    glBindVertexArray(myVAO[iTable1_3]); //need to be changed
    glBufferData(GL_ARRAY_BUFFER, sizeof(table1topVerts), table1topVerts, GL_STATIC_DRAW);
    glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);	   // Vertex positions in the VBO
    glEnableVertexAttribArray(vertPos_loc);									// Enable the stored vertices
    glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));	// Vertex normals in the VBO
    glEnableVertexAttribArray(vertNormal_loc);									// Enable the stored vertices
    glVertexAttribPointer(vertTexCoords_loc, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));	// Vertex texture coordinates in the VBO
    glEnableVertexAttribArray(vertTexCoords_loc);									// Enable the stored vertices
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[iTable1_3]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(table1topElts), table1topElts, GL_STATIC_DRAW);

    float table1botVerts[] = {
    -5.0f, 2.5f, -5.0f,           0.0f, -1.0f, 0.0f,        0.0f, 0.0f,       // bottom left coordinate
    -2.0f, 2.5f, -5.0f,           0.0f, -1.0f, 0.0f,        1.0f, 0.0f,       // bottom right coordinate
    -5.0f, 2.5f, -3.0f,           0.0f, -1.0f, 0.0f,        0.0f, 1.0f,       // top left coordinate
    -2.0f, 2.5f, -3.0f,           0.0f, -1.0f, 0.0f,        1.0f, 1.0f,       // top right coordinate
    };

    unsigned int table1botElts[] = { 0, 1, 2, 3 };
    glBindBuffer(GL_ARRAY_BUFFER, myVBO[iTable1_4]); //need to be changed
    glBindVertexArray(myVAO[iTable1_4]); //need to be changed
    glBufferData(GL_ARRAY_BUFFER, sizeof(table1botVerts), table1botVerts, GL_STATIC_DRAW);
    glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);	   // Vertex positions in the VBO
    glEnableVertexAttribArray(vertPos_loc);									// Enable the stored vertices
    glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));	// Vertex normals in the VBO
    glEnableVertexAttribArray(vertNormal_loc);									// Enable the stored vertices
    glVertexAttribPointer(vertTexCoords_loc, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));	// Vertex texture coordinates in the VBO
    glEnableVertexAttribArray(vertTexCoords_loc);									// Enable the stored vertices
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[iTable1_4]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(table1botElts), table1botElts, GL_STATIC_DRAW);

    //cylinder trash can

    //table 2

    //table legs 4 cylinders, 2 cylinders between the 2 legs , and a cylinder between these 2.



    // -2.0f, 2.5f, -5.0f,
    // -2.0f, 2.0f, -5.0f,
    // -2.0f, 2.5f, -2.0f,
    // -2.0f, 2.0f, -2.0f,
    //  2.0f, 2.5f, -2.0f,
    //  2.0f, 2.0f, -2.0f,
    //  2.0f, 2.5f, -5.0f,
    //  2.0f, 2.0f, -5.0f,

    float table2frontVerts[] = {
    -2.0f, 1.5f, -2.0f,           0.0f, 0.0f, 1.0f,        0.0f, 0.0f,       // bottom left coordinate
     2.0f, 1.5f, -2.0f,           0.0f, 0.0f, 1.0f,        1.0f, 0.0f,       // bottom right coordinate
    -2.0f, 1.6f, -2.0f,           0.0f, 0.0f, 1.0f,        0.0f, 1.0f,       // top left coordinate
     2.0f, 1.6f, -2.0f,           0.0f, 0.0f, 1.0f,        1.0f, 1.0f,       // top right coordinate
    };

    unsigned int table2frontElts[] = { 0, 1, 2, 3 };
    glBindBuffer(GL_ARRAY_BUFFER, myVBO[iTable2_1]); //need to be changed
    glBindVertexArray(myVAO[iTable2_1]); //need to be changed
    glBufferData(GL_ARRAY_BUFFER, sizeof(table2frontVerts), table2frontVerts, GL_STATIC_DRAW);
    glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);	   // Vertex positions in the VBO
    glEnableVertexAttribArray(vertPos_loc);									// Enable the stored vertices
    glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));	// Vertex normals in the VBO
    glEnableVertexAttribArray(vertNormal_loc);									// Enable the stored vertices
    glVertexAttribPointer(vertTexCoords_loc, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));	// Vertex texture coordinates in the VBO
    glEnableVertexAttribArray(vertTexCoords_loc);									// Enable the stored vertices
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[iTable2_1]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(table2frontElts), table2frontElts, GL_STATIC_DRAW);

    float table2leftVerts[] = {
    -2.0f, 1.5f, -5.0f,          -1.0f, 0.0f, 0.0f,        0.0f, 0.0f,       // bottom left coordinate
    -2.0f, 1.5f, -2.0f,          -1.0f, 0.0f, 0.0f,        1.0f, 0.0f,       // bottom right coordinate
    -2.0f, 1.6f, -5.0f,          -1.0f, 0.0f, 0.0f,        0.0f, 1.0f,       // top left coordinate
    -2.0f, 1.6f, -2.0f,          -1.0f, 0.0f, 0.0f,        1.0f, 1.0f,       // top right coordinate
    };

    unsigned int table2leftElts[] = { 0, 1, 2, 3 };
    glBindBuffer(GL_ARRAY_BUFFER, myVBO[iTable2_2]); //need to be changed
    glBindVertexArray(myVAO[iTable2_2]); //need to be changed
    glBufferData(GL_ARRAY_BUFFER, sizeof(table2leftVerts), table2leftVerts, GL_STATIC_DRAW);
    glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);	   // Vertex positions in the VBO
    glEnableVertexAttribArray(vertPos_loc);									// Enable the stored vertices
    glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));	// Vertex normals in the VBO
    glEnableVertexAttribArray(vertNormal_loc);									// Enable the stored vertices
    glVertexAttribPointer(vertTexCoords_loc, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));	// Vertex texture coordinates in the VBO
    glEnableVertexAttribArray(vertTexCoords_loc);									// Enable the stored vertices
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[iTable2_2]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(table2leftElts), table2leftElts, GL_STATIC_DRAW);

    float table2rightVerts[] = {
     2.0f, 1.5f, -2.0f,           1.0f, 0.0f, 0.0f,        0.0f, 0.0f,       // bottom left coordinate
     2.0f, 1.5f, -5.0f,           1.0f, 0.0f, 0.0f,        1.0f, 0.0f,       // bottom right coordinate
     2.0f, 1.6f, -2.0f,           1.0f, 0.0f, 0.0f,        0.0f, 1.0f,       // top left coordinate
     2.0f, 1.6f, -5.0f,           1.0f, 0.0f, 0.0f,        1.0f, 1.0f,       // top right coordinate
    };

    unsigned int table2rightElts[] = { 0, 1, 2, 3 };
    glBindBuffer(GL_ARRAY_BUFFER, myVBO[iTable2_3]); //need to be changed
    glBindVertexArray(myVAO[iTable2_3]); //need to be changed
    glBufferData(GL_ARRAY_BUFFER, sizeof(table2rightVerts), table2rightVerts, GL_STATIC_DRAW);
    glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);	   // Vertex positions in the VBO
    glEnableVertexAttribArray(vertPos_loc);									// Enable the stored vertices
    glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));	// Vertex normals in the VBO
    glEnableVertexAttribArray(vertNormal_loc);									// Enable the stored vertices
    glVertexAttribPointer(vertTexCoords_loc, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));	// Vertex texture coordinates in the VBO
    glEnableVertexAttribArray(vertTexCoords_loc);									// Enable the stored vertices
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[iTable2_3]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(table2rightElts), table2rightElts, GL_STATIC_DRAW);

    float table2topVerts[] = {
    -2.0f, 1.6f, -2.0f,           0.0f, 1.0f, 0.0f,        0.0f, 0.0f,       // bottom left coordinate
     2.0f, 1.6f, -2.0f,           0.0f, 1.0f, 0.0f,        1.0f, 0.0f,       // bottom right coordinate
    -2.0f, 1.6f, -5.0f,           0.0f, 1.0f, 0.0f,        0.0f, 1.0f,       // top left coordinate
     2.0f, 1.6f, -5.0f,           0.0f, 1.0f, 0.0f,        1.0f, 1.0f,       // top right coordinate
    };

    unsigned int table2topElts[] = { 0, 1, 2, 3 };
    glBindBuffer(GL_ARRAY_BUFFER, myVBO[iTable2_4]); //need to be changed
    glBindVertexArray(myVAO[iTable2_4]); //need to be changed
    glBufferData(GL_ARRAY_BUFFER, sizeof(table2topVerts), table2topVerts, GL_STATIC_DRAW);
    glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);	   // Vertex positions in the VBO
    glEnableVertexAttribArray(vertPos_loc);									// Enable the stored vertices
    glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));	// Vertex normals in the VBO
    glEnableVertexAttribArray(vertNormal_loc);									// Enable the stored vertices
    glVertexAttribPointer(vertTexCoords_loc, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));	// Vertex texture coordinates in the VBO
    glEnableVertexAttribArray(vertTexCoords_loc);									// Enable the stored vertices
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[iTable2_4]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(table2topElts), table2topElts, GL_STATIC_DRAW);

    float table2botVerts[] = {
    -2.0f, 1.5f, -5.0f,          0.0f, -1.0f, 0.0f,        0.0f, 0.0f,       // bottom left coordinate
     2.0f, 1.5f, -5.0f,           0.0f, -1.0f, 0.0f,        1.0f, 0.0f,       // bottom right coordinate
    -2.0f, 1.5f, -2.0f,           0.0f, -1.0f, 0.0f,        0.0f, 1.0f,       // top left coordinate
     2.0f, 1.5f, -2.0f,           0.0f, -1.0f, 0.0f,        1.0f, 1.0f,       // top right coordinate
    };

    unsigned int table2botElts[] = { 0, 1, 2, 3 };
    glBindBuffer(GL_ARRAY_BUFFER, myVBO[iTable2_5]); //need to be changed
    glBindVertexArray(myVAO[iTable2_5]); //need to be changed
    glBufferData(GL_ARRAY_BUFFER, sizeof(table2botVerts), table2botVerts, GL_STATIC_DRAW);
    glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);	   // Vertex positions in the VBO
    glEnableVertexAttribArray(vertPos_loc);									// Enable the stored vertices
    glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));	// Vertex normals in the VBO
    glEnableVertexAttribArray(vertNormal_loc);									// Enable the stored vertices
    glVertexAttribPointer(vertTexCoords_loc, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));	// Vertex texture coordinates in the VBO
    glEnableVertexAttribArray(vertTexCoords_loc);									// Enable the stored vertices
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[iTable2_5]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(table2botElts), table2botElts, GL_STATIC_DRAW);

    float closetVerts[] = {
        // Position              // Normal                  // Texture coordinates
         2.0f, 0.0f, -3.49f,      0.0f, 0.0f, 1.0f,          0.0f, 0.0f,         // Back left
         5.0f, 0.0f, -3.49f,      0.0f, 0.0f, 1.0f,          1.0f, 0.0f,         // Back right
         2.0f, 5.0f,  -3.49f,      0.0f, 0.0f, 1.0f,          0.0f, 1.0f,         // Front right
         5.0f, 5.0f,  -3.49f,      0.0f, 0.0f, 1.0f,          1.0f, 1.0f,         // Front left
    };

    unsigned int closetElts[] = { 0, 1, 2, 3 };
    glBindBuffer(GL_ARRAY_BUFFER, myVBO[iClosetF]);
    glBindVertexArray(myVAO[iClosetF]);
    glBufferData(GL_ARRAY_BUFFER, sizeof(closetVerts), closetVerts, GL_STATIC_DRAW);
    glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);	   // Vertex positions in the VBO
    glEnableVertexAttribArray(vertPos_loc);									// Enable the stored vertices
    glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));	// Vertex normals in the VBO
    glEnableVertexAttribArray(vertNormal_loc);									// Enable the stored vertices
    glVertexAttribPointer(vertTexCoords_loc, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));	// Vertex texture coordinates in the VBO
    glEnableVertexAttribArray(vertTexCoords_loc);									// Enable the stored vertices
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[iClosetF]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(closetElts), closetElts, GL_STATIC_DRAW);



    check_for_opengl_errors();      // Watch the console window for error messages!
}

void MyRemeshGeometries() 
{
// IT IS NOT NECESSARY TO REMESH EITHER THE FLOOR OR THE BACK WALL
// YOU DO NOT NEED TO CHANGE THIS FOR PROJECT #6.

    //SamsRemeshCircularSurf();
    texSphere.Remesh(meshRes, meshRes);
    texCylinder.Remesh(meshRes, meshRes, meshRes);
    //texTorus.Remesh(meshRes, meshRes );

    check_for_opengl_errors();      // Watch the console window for error messages!
}

// **********************************************
// MODIFY THIS ROUTINE TO RENDER THE FLOOR, THE BACK WALL,
//    AND THE SPHERES AND THE CYLINDER. -- WITH TEXTURES
// **********************************************

void MyRenderGeometries() {

    float matEntries[16];       // Temporary storage for floats
    // ******
    // Render the Floor - using a procedural texture map
    // ******


    selectShaderProgram(shaderProgramBitmap);
    glBindVertexArray(myVAO[iFloor]);                // Select the floor VAO (Vertex Array Object)
    materialUnderTexture.LoadIntoShaders();         // Use the bright underlying color
    viewMatrix.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[0]);
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    // Draw the floor as a single triangle strip
    glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_INT, (void*)0);
    glUniform1i(applyTextureLocation, false);           // Turn off applying texture!
    check_for_opengl_errors();


    //selectShaderProgram(shaderProgramProc);
    //glBindVertexArray(myVAO[iFloor]);                // Select the floor VAO (Vertex Array Object)
    //materialUnderTexture.LoadIntoShaders();         // Use the bright underlying color
    //viewMatrix.DumpByColumns(matEntries);           // Apply the model view matrix
    //glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    //glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    //// Draw the floor as a single triangle strip
    //glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_INT, (void*)0);    
    //glUniform1i(applyTextureLocation, false);           // Turn off applying texture!
    //check_for_opengl_errors();

    //if (renderFloorOnly) {
    //    return;
    //}

    // **************
    // Render the circular surface
    //selectShaderProgram(shaderProgramBitmap);
    //SamsRenderCircularSurf();

    //render window

    selectShaderProgram(shaderProgramBitmap);
    glBindVertexArray(myVAO[iWindow]);                // Select the floor VAO (Vertex Array Object)
    materialUnderTexture.LoadIntoShaders();         // Use the bright underlying color
    viewMatrix.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[3]);
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    // Draw the floor as a single triangle strip
    glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_INT, (void*)0);
    glUniform1i(applyTextureLocation, false);           // Turn off applying texture!
    check_for_opengl_errors();
    

    // ************ 
    // Render the back wall
    //  YOU MUST WRITE THIS. IT WILL BE SIMILAR TO THE FLOOR ABOVE. 
    //  BUT USE A BITMAP (shaderProgramBitmap) INSTEAD OF A PROCEDURAL TEXTURE.

    selectShaderProgram(shaderProgramBitmap);
    glBindVertexArray(myVAO[iWall]);                // Select the floor VAO (Vertex Array Object)
    materialUnderTexture.LoadIntoShaders();         // Use the bright underlying color
    viewMatrix.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[4]);
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    // Draw the floor as a single triangle strip
    glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_INT, (void*)0);
    glUniform1i(applyTextureLocation, false);           // Turn off applying texture!
    check_for_opengl_errors();

    selectShaderProgram(shaderProgramBitmap);
    glBindVertexArray(myVAO[iWall2]);                // Select the floor VAO (Vertex Array Object)
    materialUnderTexture.LoadIntoShaders();         // Use the bright underlying color
    viewMatrix.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[4]);
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    // Draw the floor as a single triangle strip
    glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_INT, (void*)0);
    glUniform1i(applyTextureLocation, false);           // Turn off applying texture!
    check_for_opengl_errors();

    selectShaderProgram(shaderProgramBitmap);
    glBindVertexArray(myVAO[iWall3]);                // Select the floor VAO (Vertex Array Object)
    materialUnderTexture.LoadIntoShaders();         // Use the bright underlying color
    viewMatrix.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[4]);
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    // Draw the floor as a single triangle strip
    glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_INT, (void*)0);
    glUniform1i(applyTextureLocation, false);           // Turn off applying texture!
    check_for_opengl_errors();



    //render the bed

    selectShaderProgram(shaderProgramBitmap);
    glBindVertexArray(myVAO[iBed1]);                // Select the floor VAO (Vertex Array Object)
    materialUnderTexture.LoadIntoShaders();         // Use the bright underlying color
    viewMatrix.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[11]);
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    // Draw the floor as a single triangle strip
    glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_INT, (void*)0);
    glUniform1i(applyTextureLocation, false);           // Turn off applying texture!
    check_for_opengl_errors();

    selectShaderProgram(shaderProgramBitmap);
    glBindVertexArray(myVAO[iBed7]);                // Select the floor VAO (Vertex Array Object)
    materialUnderTexture.LoadIntoShaders();         // Use the bright underlying color
    viewMatrix.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[11]);
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    // Draw the floor as a single triangle strip
    glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_INT, (void*)0);
    glUniform1i(applyTextureLocation, false);           // Turn off applying texture!
    check_for_opengl_errors();

    selectShaderProgram(shaderProgramBitmap);
    glBindVertexArray(myVAO[iBed2]);                // Select the floor VAO (Vertex Array Object)
    materialUnderTexture.LoadIntoShaders();         // Use the bright underlying color
    viewMatrix.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[6]);
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    // Draw the floor as a single triangle strip
    glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_INT, (void*)0);
    glUniform1i(applyTextureLocation, false);           // Turn off applying texture!
    check_for_opengl_errors();

    selectShaderProgram(shaderProgramBitmap);
    glBindVertexArray(myVAO[iBed3]);                // Select the floor VAO (Vertex Array Object)
    materialUnderTexture.LoadIntoShaders();         // Use the bright underlying color
    viewMatrix.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[11]);
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    // Draw the floor as a single triangle strip
    glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_INT, (void*)0);
    glUniform1i(applyTextureLocation, false);           // Turn off applying texture!
    check_for_opengl_errors();

    selectShaderProgram(shaderProgramBitmap);
    glBindVertexArray(myVAO[iBed4]);                // Select the floor VAO (Vertex Array Object)
    materialUnderTexture.LoadIntoShaders();         // Use the bright underlying color
    viewMatrix.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[6]);
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    // Draw the floor as a single triangle strip
    glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_INT, (void*)0);
    glUniform1i(applyTextureLocation, false);           // Turn off applying texture!
    check_for_opengl_errors();

    selectShaderProgram(shaderProgramBitmap);
    glBindVertexArray(myVAO[iBed5]);                // Select the floor VAO (Vertex Array Object)
    materialUnderTexture.LoadIntoShaders();         // Use the bright underlying color
    viewMatrix.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[6]);
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    // Draw the floor as a single triangle strip
    glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_INT, (void*)0);
    glUniform1i(applyTextureLocation, false);           // Turn off applying texture!
    check_for_opengl_errors();

    selectShaderProgram(shaderProgramBitmap);
    glBindVertexArray(myVAO[iBed6]);                // Select the floor VAO (Vertex Array Object)
    materialUnderTexture.LoadIntoShaders();         // Use the bright underlying color
    viewMatrix.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[11]);
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    // Draw the floor as a single triangle strip
    glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_INT, (void*)0);
    glUniform1i(applyTextureLocation, false);           // Turn off applying texture!
    check_for_opengl_errors();



    //render desk 1

    

    selectShaderProgram(shaderProgramBitmap);
    glBindVertexArray(myVAO[iTable1_1]);                // Select the floor VAO (Vertex Array Object)
    materialUnderTexture.LoadIntoShaders();         // Use the bright underlying color
    viewMatrix.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[9]);
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    // Draw the floor as a single triangle strip
    glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_INT, (void*)0);
    glUniform1i(applyTextureLocation, false);           // Turn off applying texture!
    check_for_opengl_errors();

    selectShaderProgram(shaderProgramBitmap);
    glBindVertexArray(myVAO[iTable1_2]);                // Select the floor VAO (Vertex Array Object)
    materialUnderTexture.LoadIntoShaders();         // Use the bright underlying color
    viewMatrix.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[9]);
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    // Draw the floor as a single triangle strip
    glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_INT, (void*)0);
    glUniform1i(applyTextureLocation, false);           // Turn off applying texture!
    check_for_opengl_errors();

    selectShaderProgram(shaderProgramBitmap);
    glBindVertexArray(myVAO[iTable1_3]);                // Select the floor VAO (Vertex Array Object)
    materialUnderTexture.LoadIntoShaders();         // Use the bright underlying color
    viewMatrix.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[9]);
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    // Draw the floor as a single triangle strip
    glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_INT, (void*)0);
    glUniform1i(applyTextureLocation, false);           // Turn off applying texture!
    check_for_opengl_errors();

    selectShaderProgram(shaderProgramBitmap);
    glBindVertexArray(myVAO[iTable1_4]);                // Select the floor VAO (Vertex Array Object)
    materialUnderTexture.LoadIntoShaders();         // Use the bright underlying color
    viewMatrix.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[9]);
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    // Draw the floor as a single triangle strip
    glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_INT, (void*)0);
    glUniform1i(applyTextureLocation, false);           // Turn off applying texture!
    check_for_opengl_errors();

    selectShaderProgram(shaderProgramBitmap);
    glBindVertexArray(myVAO[iTable1_5]);                // Select the floor VAO (Vertex Array Object)
    materialUnderTexture.LoadIntoShaders();         // Use the bright underlying color
    viewMatrix.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[9]);
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    // Draw the floor as a single triangle strip
    glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_INT, (void*)0);
    glUniform1i(applyTextureLocation, false);           // Turn off applying texture!
    check_for_opengl_errors();

    selectShaderProgram(shaderProgramBitmap);
    glBindVertexArray(myVAO[iTable1_6]);                // Select the floor VAO (Vertex Array Object)
    materialUnderTexture.LoadIntoShaders();         // Use the bright underlying color
    viewMatrix.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[9]);
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    // Draw the floor as a single triangle strip
    glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_INT, (void*)0);
    glUniform1i(applyTextureLocation, false);           // Turn off applying texture!
    check_for_opengl_errors();


    //render desk 2


    selectShaderProgram(shaderProgramBitmap);
    glBindVertexArray(myVAO[iTable2_1]);                // Select the floor VAO (Vertex Array Object)
    materialUnderTexture.LoadIntoShaders();         // Use the bright underlying color
    viewMatrix.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[5]);
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    // Draw the floor as a single triangle strip
    glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_INT, (void*)0);
    glUniform1i(applyTextureLocation, false);           // Turn off applying texture!
    check_for_opengl_errors();

    selectShaderProgram(shaderProgramBitmap);
    glBindVertexArray(myVAO[iTable2_2]);                // Select the floor VAO (Vertex Array Object)
    materialUnderTexture.LoadIntoShaders();         // Use the bright underlying color
    viewMatrix.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[5]);
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    // Draw the floor as a single triangle strip
    glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_INT, (void*)0);
    glUniform1i(applyTextureLocation, false);           // Turn off applying texture!
    check_for_opengl_errors();

    selectShaderProgram(shaderProgramBitmap);
    glBindVertexArray(myVAO[iTable2_3]);                // Select the floor VAO (Vertex Array Object)
    materialUnderTexture.LoadIntoShaders();         // Use the bright underlying color
    viewMatrix.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[5]);
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    // Draw the floor as a single triangle strip
    glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_INT, (void*)0);
    glUniform1i(applyTextureLocation, false);           // Turn off applying texture!
    check_for_opengl_errors();

    selectShaderProgram(shaderProgramBitmap);
    glBindVertexArray(myVAO[iTable2_4]);                // Select the floor VAO (Vertex Array Object)
    materialUnderTexture.LoadIntoShaders();         // Use the bright underlying color
    viewMatrix.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[5]);
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    // Draw the floor as a single triangle strip
    glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_INT, (void*)0);
    glUniform1i(applyTextureLocation, false);           // Turn off applying texture!
    check_for_opengl_errors();

    selectShaderProgram(shaderProgramBitmap);
    glBindVertexArray(myVAO[iTable2_5]);                // Select the floor VAO (Vertex Array Object)
    materialUnderTexture.LoadIntoShaders();         // Use the bright underlying color
    viewMatrix.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[5]);
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    // Draw the floor as a single triangle strip
    glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_INT, (void*)0);
    glUniform1i(applyTextureLocation, false);           // Turn off applying texture!
    check_for_opengl_errors();

    //door
    selectShaderProgram(shaderProgramBitmap);
    glBindVertexArray(myVAO[iDoor]);                // Select the floor VAO (Vertex Array Object)
    materialUnderTexture.LoadIntoShaders();         // Use the bright underlying color
    viewMatrix.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[5]);
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    // Draw the floor as a single triangle strip
    glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_INT, (void*)0);
    glUniform1i(applyTextureLocation, false);           // Turn off applying texture!
    check_for_opengl_errors();



    //closet front
    selectShaderProgram(shaderProgramBitmap);
    glBindVertexArray(myVAO[iClosetF]);                // Select the floor VAO (Vertex Array Object)
    materialUnderTexture.LoadIntoShaders();         // Use the bright underlying color
    viewMatrix.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[10]);
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    // Draw the floor as a single triangle strip
    glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_INT, (void*)0);
    glUniform1i(applyTextureLocation, false);           // Turn off applying texture!
    check_for_opengl_errors();


    //map
    selectShaderProgram(shaderProgramBitmap);
    glBindVertexArray(myVAO[iMap]);                // Select the floor VAO (Vertex Array Object)
    materialUnderTexture.LoadIntoShaders();         // Use the bright underlying color
    viewMatrix.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[13]);
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    // Draw the floor as a single triangle strip
    glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_INT, (void*)0);
    glUniform1i(applyTextureLocation, false);           // Turn off applying texture!
    check_for_opengl_errors();

    //laptop
    selectShaderProgram(shaderProgramBitmap);
    glBindVertexArray(myVAO[iRazer]);                // Select the floor VAO (Vertex Array Object)
    materialUnderTexture.LoadIntoShaders();         // Use the bright underlying color
    viewMatrix.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[14]);
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    // Draw the floor as a single triangle strip
    glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_INT, (void*)0);
    glUniform1i(applyTextureLocation, false);           // Turn off applying texture!
    check_for_opengl_errors();


    // *************
    // Render two spheres and a cylinder
    // YOU MUST MODIFY THE CODE BELOW, AND ADD TEXTURES TO THE SPHERE AND THE CAPS OF THE CYLINDER.

    // Render a sphere with a earth image texture map
    //  YOU DO NOT NEED TO MODIFY THIS SPHERE OR ITS TEXTURE MAP
    LinearMapR4 matDemo = viewMatrix;
    //matDemo.Mult_glTranslate(-3.5, 1.1, 0.4);
    //matDemo.DumpByColumns(matEntries);           // Apply the model view matrix
    //glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    //glBindTexture(GL_TEXTURE_2D, TextureNames[3]);     // Choose Earth image texture
    //glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    //texSphere.Render();                                 // Render the sphere
    //glUniform1i(applyTextureLocation, false);           // Turn off applying texture!

    //// Render a sphere with a texture map 
    //// ADD A TEXTURE MAP TO THIS SPHERE - SIMILAR TO THE CODE ABOVE
    matDemo = viewMatrix;
    matDemo.Mult_glTranslate(3.5, 0.5, 0.4);
    matDemo.Mult_glScale(0.5, 0.5, 0.5);
    matDemo.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[12]);     // Choose Earth image texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    texSphere.Render();                                 // Render the sphere
    glUniform1i(applyTextureLocation, false);           // Turn off applying texture!


    //// Render a cylinder 
    //// YOU MAY LEAVE THE TEXTURE MAP ON THE SIDE OF THE CYLINDER
    //// YOU MUST ADD TEXTURE MAPS TO THE TOP AND BOTTOM FACES OF THE CYLINDER
    //// NOTE THERE ARE SEPARATE RENDER COMMANDS FOR THE THREE PARTS OF THE CYLINDER.
    //// YOU WILL ALSO CHANGE THE ORIENTATION OF THE CYLINDER


    //table1 left leg
    matDemo = viewMatrix;
    matDemo.Mult_glTranslate(-0.0f, 1.25f / 2, -0.0);
    matDemo.Mult_glTranslate(-4.5f, 0.0, -4.2f);

    matDemo.Mult_glRotate(0.25*PI, 0, 1, 0);
    matDemo.Mult_glScale(sqrt(2) / 10.0f, 5 / 8.0f, sqrt(2) / 10.0f);
    
    matDemo.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[1]);     // Choose texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    texCylinder.RenderSide();                             // Render the sphere side
    glUniform1i(applyTextureLocation, false);             // Turn off applying texture!

    glBindTexture(GL_TEXTURE_2D, TextureNames[1]);     // Choose texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    texCylinder.RenderTop();                              // RENDER THIS WITH A TEXTURE MAP
    glUniform1i(applyTextureLocation, false);             // Turn off applying texture!

    glBindTexture(GL_TEXTURE_2D, TextureNames[1]);     // Choose texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    texCylinder.RenderBase();                             // RENDER THIS WITH A TEXTURE MAP
    glUniform1i(applyTextureLocation, false);             // Turn off applying texture!


    matDemo = viewMatrix;
    matDemo.Mult_glTranslate(-0.0, 1.25 + 1.25f/2, -0.0);
    matDemo.Mult_glTranslate(-4.5f, 0.0, -4.2f);

    matDemo.Mult_glRotate(0.25 * PI, 0, 1, 0);
    matDemo.Mult_glScale(sqrt(2) / 12.0f, 5 / 8.0f, sqrt(2) / 12.0f);

    matDemo.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[1]);     // Choose texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    texCylinder.RenderSide();                             // Render the sphere side
    glUniform1i(applyTextureLocation, false);             // Turn off applying texture!

    glBindTexture(GL_TEXTURE_2D, TextureNames[1]);     // Choose texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    texCylinder.RenderTop();                              // RENDER THIS WITH A TEXTURE MAP
    glUniform1i(applyTextureLocation, false);             // Turn off applying texture!

    glBindTexture(GL_TEXTURE_2D, TextureNames[1]);     // Choose texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    texCylinder.RenderBase();                             // RENDER THIS WITH A TEXTURE MAP
    glUniform1i(applyTextureLocation, false);             // Turn off applying texture!


    matDemo = viewMatrix;

    
    matDemo.Mult_glTranslate(-0.0, 0.1f, 0.0f);
    matDemo.Mult_glTranslate(-4.5f, 0.0, -4.2f);
    
    matDemo.Mult_glRotate(0.5 * PI, 1, 0, 0);
    matDemo.Mult_glRotate(0.25 * PI, 0, 1, 0);

    matDemo.Mult_glTranslate(0, 0.2f, 0);
    matDemo.Mult_glScale(sqrt(2) / 10.0f, 8 / 8.0f, sqrt(2) / 10.0f);
    
 

    matDemo.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[1]);     // Choose texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    texCylinder.RenderSide();                             // Render the sphere side
    glUniform1i(applyTextureLocation, false);             // Turn off applying texture!

    glBindTexture(GL_TEXTURE_2D, TextureNames[1]);     // Choose texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    texCylinder.RenderTop();                              // RENDER THIS WITH A TEXTURE MAP
    glUniform1i(applyTextureLocation, false);             // Turn off applying texture!

    glBindTexture(GL_TEXTURE_2D, TextureNames[1]);     // Choose texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    texCylinder.RenderBase();                             // RENDER THIS WITH A TEXTURE MAP
    glUniform1i(applyTextureLocation, false);             // Turn off applying texture!












    //table1 right leg
    matDemo = viewMatrix;
    matDemo.Mult_glTranslate(-0.0f, 1.25f / 2, -0.0);
    matDemo.Mult_glTranslate(-2.5f, 0.0, -4.2f);

    matDemo.Mult_glRotate(0.25 * PI, 0, 1, 0);
    matDemo.Mult_glScale(sqrt(2) / 10.0f, 5 / 8.0f, sqrt(2) / 10.0f);

    matDemo.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[1]);     // Choose texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    texCylinder.RenderSide();                             // Render the sphere side
    glUniform1i(applyTextureLocation, false);             // Turn off applying texture!

    glBindTexture(GL_TEXTURE_2D, TextureNames[1]);     // Choose texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    texCylinder.RenderTop();                              // RENDER THIS WITH A TEXTURE MAP
    glUniform1i(applyTextureLocation, false);             // Turn off applying texture!

    glBindTexture(GL_TEXTURE_2D, TextureNames[1]);     // Choose texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    texCylinder.RenderBase();                             // RENDER THIS WITH A TEXTURE MAP
    glUniform1i(applyTextureLocation, false);             // Turn off applying texture!


    matDemo = viewMatrix;
    matDemo.Mult_glTranslate(-0.0, 1.25 + 1.25f / 2, -0.0);
    matDemo.Mult_glTranslate(-2.5f, 0.0, -4.2f);

    matDemo.Mult_glRotate(0.25 * PI, 0, 1, 0);
    matDemo.Mult_glScale(sqrt(2) / 12.0f, 5 / 8.0f, sqrt(2) / 12.0f);

    matDemo.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[1]);     // Choose texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    texCylinder.RenderSide();                             // Render the sphere side
    glUniform1i(applyTextureLocation, false);             // Turn off applying texture!

    glBindTexture(GL_TEXTURE_2D, TextureNames[1]);     // Choose texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    texCylinder.RenderTop();                              // RENDER THIS WITH A TEXTURE MAP
    glUniform1i(applyTextureLocation, false);             // Turn off applying texture!

    glBindTexture(GL_TEXTURE_2D, TextureNames[1]);     // Choose texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    texCylinder.RenderBase();                             // RENDER THIS WITH A TEXTURE MAP
    glUniform1i(applyTextureLocation, false);             // Turn off applying texture!


    matDemo = viewMatrix;


    matDemo.Mult_glTranslate(-0.0, 0.1f, 0.0f);
    matDemo.Mult_glTranslate(-2.5f, 0.0, -4.2f);

    matDemo.Mult_glRotate(0.5 * PI, 1, 0, 0);
    matDemo.Mult_glRotate(0.25 * PI, 0, 1, 0);

    matDemo.Mult_glTranslate(0, 0.2f, 0);

    matDemo.Mult_glScale(sqrt(2) / 10.0f, 8 / 8.0f, sqrt(2) / 10.0f);






    matDemo.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[1]);     // Choose texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    texCylinder.RenderSide();                             // Render the sphere side
    glUniform1i(applyTextureLocation, false);             // Turn off applying texture!

    glBindTexture(GL_TEXTURE_2D, TextureNames[1]);     // Choose texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    texCylinder.RenderTop();                              // RENDER THIS WITH A TEXTURE MAP
    glUniform1i(applyTextureLocation, false);             // Turn off applying texture!

    glBindTexture(GL_TEXTURE_2D, TextureNames[1]);     // Choose texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    texCylinder.RenderBase();                             // RENDER THIS WITH A TEXTURE MAP
    glUniform1i(applyTextureLocation, false);             // Turn off applying texture!


    //table 2 legs


    matDemo = viewMatrix;



    matDemo.Mult_glTranslate(-1.7f, 0.75f, -2.3f);

    matDemo.Mult_glRotate(0.25 * PI, 0, 1, 0);

    matDemo.Mult_glScale(sqrt(2) / 8.0f, 6 / 8.0f, sqrt(2) / 8.0f);



    matDemo.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[5]);     // Choose texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    texCylinder.RenderSide();                             // Render the sphere side
    glUniform1i(applyTextureLocation, false);             // Turn off applying texture!

    glBindTexture(GL_TEXTURE_2D, TextureNames[5]);     // Choose texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    texCylinder.RenderTop();                              // RENDER THIS WITH A TEXTURE MAP
    glUniform1i(applyTextureLocation, false);             // Turn off applying texture!

    glBindTexture(GL_TEXTURE_2D, TextureNames[5]);     // Choose texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    texCylinder.RenderBase();                             // RENDER THIS WITH A TEXTURE MAP
    glUniform1i(applyTextureLocation, false);             // Turn off applying texture!



    matDemo = viewMatrix;



    matDemo.Mult_glTranslate(-1.7f, 0.75f, -4.7f);

    matDemo.Mult_glRotate(0.25 * PI, 0, 1, 0);

    matDemo.Mult_glScale(sqrt(2) / 8.0f, 6 / 8.0f, sqrt(2) / 8.0f);



    matDemo.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[5]);     // Choose texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    texCylinder.RenderSide();                             // Render the sphere side
    glUniform1i(applyTextureLocation, false);             // Turn off applying texture!

    glBindTexture(GL_TEXTURE_2D, TextureNames[5]);     // Choose texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    texCylinder.RenderTop();                              // RENDER THIS WITH A TEXTURE MAP
    glUniform1i(applyTextureLocation, false);             // Turn off applying texture!

    glBindTexture(GL_TEXTURE_2D, TextureNames[5]);     // Choose texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    texCylinder.RenderBase();                             // RENDER THIS WITH A TEXTURE MAP
    glUniform1i(applyTextureLocation, false);             // Turn off applying texture!



    matDemo = viewMatrix;



    matDemo.Mult_glTranslate(1.7f, 0.75f, -2.3f);

    matDemo.Mult_glRotate(0.25 * PI, 0, 1, 0);

    matDemo.Mult_glScale(sqrt(2) / 8.0f, 6 / 8.0f, sqrt(2) / 8.0f);



    matDemo.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[5]);     // Choose texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    texCylinder.RenderSide();                             // Render the sphere side
    glUniform1i(applyTextureLocation, false);             // Turn off applying texture!

    glBindTexture(GL_TEXTURE_2D, TextureNames[5]);     // Choose texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    texCylinder.RenderTop();                              // RENDER THIS WITH A TEXTURE MAP
    glUniform1i(applyTextureLocation, false);             // Turn off applying texture!

    glBindTexture(GL_TEXTURE_2D, TextureNames[5]);     // Choose texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    texCylinder.RenderBase();                             // RENDER THIS WITH A TEXTURE MAP
    glUniform1i(applyTextureLocation, false);             // Turn off applying texture!


    matDemo = viewMatrix;



    matDemo.Mult_glTranslate(1.7f, 0.75f, -4.7f);

    matDemo.Mult_glRotate(0.25 * PI, 0, 1, 0);

    matDemo.Mult_glScale(sqrt(2) / 8.0f, 6 / 8.0f, sqrt(2) / 8.0f);



    matDemo.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[5]);     // Choose texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    texCylinder.RenderSide();                             // Render the sphere side
    glUniform1i(applyTextureLocation, false);             // Turn off applying texture!

    glBindTexture(GL_TEXTURE_2D, TextureNames[5]);     // Choose texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    texCylinder.RenderTop();                              // RENDER THIS WITH A TEXTURE MAP
    glUniform1i(applyTextureLocation, false);             // Turn off applying texture!

    glBindTexture(GL_TEXTURE_2D, TextureNames[5]);     // Choose texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    texCylinder.RenderBase();                             // RENDER THIS WITH A TEXTURE MAP
    glUniform1i(applyTextureLocation, false);             // Turn off applying texture!


    //closet


    matDemo = viewMatrix;



    matDemo.Mult_glTranslate(3.5f, 2.5f, -3.5f-0.75f);

    

    matDemo.Mult_glScale(sqrt(2) *1.5f, 2.5f, sqrt(2) * 0.75f);
    matDemo.Mult_glRotate(0.25 * PI, 0, 1, 0);



    matDemo.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[5]);     // Choose texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    texCylinder.RenderSide();                             // Render the sphere side
    glUniform1i(applyTextureLocation, false);             // Turn off applying texture!

    glBindTexture(GL_TEXTURE_2D, TextureNames[5]);     // Choose texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    texCylinder.RenderTop();                              // RENDER THIS WITH A TEXTURE MAP
    glUniform1i(applyTextureLocation, false);             // Turn off applying texture!

    glBindTexture(GL_TEXTURE_2D, TextureNames[5]);     // Choose texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    texCylinder.RenderBase();                             // RENDER THIS WITH A TEXTURE MAP
    glUniform1i(applyTextureLocation, false);             // Turn off applying texture!



    //pillow 

    matDemo = viewMatrix;


    matDemo.Mult_glTranslate(-0.0, 0.1f + 0.4f, 0.0f);
    matDemo.Mult_glTranslate(-3.5f, 0.0, 4.5f);

    

    matDemo.Mult_glTranslate(0, 0.2f, 0);

    matDemo.Mult_glScale(sqrt(2) / 2.0f, 3 / 12.0f, sqrt(2) / 3.0f);


    matDemo.Mult_glRotate(0.5 * PI, 0, 0, 1);
    matDemo.Mult_glRotate(0.25 * PI, 0, 1, 0);





    matDemo.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[7]);     // Choose texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    texCylinder.RenderSide();                             // Render the sphere side
    glUniform1i(applyTextureLocation, false);             // Turn off applying texture!

    glBindTexture(GL_TEXTURE_2D, TextureNames[7]);     // Choose texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    texCylinder.RenderTop();                              // RENDER THIS WITH A TEXTURE MAP
    glUniform1i(applyTextureLocation, false);             // Turn off applying texture!

    glBindTexture(GL_TEXTURE_2D, TextureNames[7]);     // Choose texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    texCylinder.RenderBase();                             // RENDER THIS WITH A TEXTURE MAP
    glUniform1i(applyTextureLocation, false);             // Turn off applying texture!




    //laptop

    matDemo = viewMatrix;


    matDemo.Mult_glTranslate(-3.5f, 0.1f + 0.4f + 2.0f, -4.0f);
    //matDemo.Mult_glTranslate(-3.5f, 0.0, 4.5f);



    matDemo.Mult_glTranslate(0, 0.2f, 0);

    matDemo.Mult_glScale(sqrt(2) / 2.0f, 3 / 16.0f, sqrt(2) / 2.5f);


    matDemo.Mult_glRotate(0.5 * PI, 0, 0, 1);
    matDemo.Mult_glRotate(0.25 * PI, 0, 1, 0);





    matDemo.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[1]);     // Choose texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    texCylinder.RenderSide();                             // Render the sphere side
    glUniform1i(applyTextureLocation, false);             // Turn off applying texture!

    glBindTexture(GL_TEXTURE_2D, TextureNames[1]);     // Choose texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    texCylinder.RenderTop();                              // RENDER THIS WITH A TEXTURE MAP
    glUniform1i(applyTextureLocation, false);             // Turn off applying texture!

    glBindTexture(GL_TEXTURE_2D, TextureNames[1]);     // Choose texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    texCylinder.RenderBase();                             // RENDER THIS WITH A TEXTURE MAP
    glUniform1i(applyTextureLocation, false);             // Turn off applying texture!










    // Renders a textured torus in the back left corner.
    // matDemo = viewMatrix;
    // matDemo.Mult_glTranslate(-4.0, 0.3, -3.0);
    // matDemo.Mult_glScale(0.8, 0.2, 0.8);
    // matDemo.DumpByColumns(matEntries);           // Apply the model view matrix
    // glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    // glBindTexture(GL_TEXTURE_2D, TextureNames[2]);     // Choose texture
    // glUniform1i(applyTextureLocation, true);            // Enable applying the texture!
    // texTorus.Render();                                  // Render the torus
    // glUniform1i(applyTextureLocation, false);           // Turn off applying texture!
        
    check_for_opengl_errors();      // Watch the console window for error messages!
}

void SamsRenderCircularSurf()
{
    float matEntries[16];       // Temporary storage for floats

    glBindVertexArray(myVAO[iCircularSurf]);

    // Calculate the model view matrix for the circular surface
    LinearMapR4 matDemo = viewMatrix;
    matDemo.Mult_glTranslate(0.0, 0.8, -2.5);     // Center in the back & raise up
    matDemo.Mult_glScale(0.18, 0.4, 0.18);         // Adjust the circular diameter and height

                                                 // Set the uniform values (they are not stored with the VAO and thus must be set again everytime
    materialUnderTexture.LoadIntoShaders();                       // Use the bright underlying material
    matDemo.DumpByColumns(matEntries);
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries); // Select the modelview matrix to place it
    glBindTexture(GL_TEXTURE_2D, TextureNames[1]);     // Choose Mandala texture
    // ONCE YOU HAVE TEXTURE COORDINATES FOR THE CIRCULAR SURFACE, PUT THE NEXT LINE BACK IN.
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
                                                                   // Draw the the triangle strips
    for (int i = 0; i < meshRes; i++) {
        glDrawElements(GL_TRIANGLE_STRIP, 1 + 2 * meshRes, GL_UNSIGNED_INT,
            (void*)(i * (1 + 2 * meshRes) * sizeof(unsigned int)));
    }
    glUniform1i(applyTextureLocation, false);           // Disable applying the texture!
}


// *******
// ADD TEXTURE COORDINATES TO EITHER YOUR OWN "MyRemeshCircularSurf" or
// TO THE PROVIDED "SamsRemeshCircularSurf"
// IF YOU USE YOUR OWN, ALSO REPLACE "SamsRenderCircularMesh" WITH YOUR
// OWN "MyRenderCircularMesh" IF NEEDED.
// TASKS FOR ADDING TEXTURE COORDINATES:
//    a. Change stride to 8*sizeof(float) instead 6*sizeof(float).
//    b. Be sure to allocate enough memory for circularVerts[].
//    c. Calculate the (s,t) texture coordinates, put them in the array.
//    d. Update the calls to glVertexAttribPointer and glEnableVertexAttribArray
//         in the routine MySetupSurfaces above.  
//       And, add new calls for the texture coordinates.

void SamsRemeshCircularSurf()
{
    // Circular surface vertices.
    int numCircularVerts = 1 + meshRes * meshRes;
    float* circularVerts = new float[8 * numCircularVerts];
    // Circular surface elements (indices to vertices in a triangle strip)
    int numCircularElts = meshRes * (1 + 2 * meshRes);
    unsigned int* circularElements = new unsigned int[numCircularElts];

    float* toPtr = circularVerts;
    *(toPtr++) = 0.0f;      // Center point
    *(toPtr++) = 1.0f;
    *(toPtr++) = 0.0f;
    *(toPtr++) = 0.0f;      // Center normal
    *(toPtr++) = 1.0f;
    *(toPtr++) = 0.0f;
    *(toPtr++) = 0.5f;
    *(toPtr++) = 0.5f;
    for (int i = 0; i < meshRes; i++) {
        float theta = (float)PI2 * ((float)i) / (float)meshRes;
        float c = cosf(theta);
        float s = sinf(theta);
        float partialC = -s;
        float partialS = c;
        VectorR3 partialTheta(partialC, 0.0, partialS);
        for (int j = 1; j <= meshRes; j++) {
            float r = 2.9f * (float)PI * ((float)j) / (float)meshRes;
            float x = r;
            float dampingFactor = 0.08f;
            float fff = (float)(1.0 + dampingFactor * r * r);
            float y = j==0 ? 1.0f : fff*sin(r)/r;
            float xprime = 1.0;
            float yprime = (x * cosf(x) + sinf(x)) / (x + 1.0f) - x * sinf(x) / ((x + 1.0f) * (x + 1.0f));
            VectorR3 partialR((double)(c * xprime), yprime, (double)(s * xprime));
            *(toPtr++) = c * x;                 // (i,j) point
            *(toPtr++) = y;
            *(toPtr++) = s * x;
            VectorR3 normal = -partialR * partialTheta;
            normal.Normalize();
            *(toPtr++) = (float)normal.x;      // (i,j) normal
            *(toPtr++) = (float)normal.y;
            *(toPtr++) = (float)normal.z;

            *(toPtr++) = (1.0f + (c * x / 2.9f / PI)) / 2.0f;
            *(toPtr++) = (1.0f + (s * x / 2.9f / PI)) / 2.0f;
       }
    }

    unsigned int* toElt = circularElements;
    for (int i = 0; i < meshRes; i++) {
        *(toElt++) = 0;         // Central vertex
        for (int j = 0; j < meshRes; j++) {
            *(toElt++) = ((i + 1) % meshRes) * meshRes + j + 1;
            *(toElt++) = i * meshRes + j + 1;
        }
    }

    glBindVertexArray(myVAO[iCircularSurf]);
    glBindBuffer(GL_ARRAY_BUFFER, myVBO[iCircularSurf]);
    glBufferData(GL_ARRAY_BUFFER, 8 * numCircularVerts * sizeof(float), circularVerts, GL_STATIC_DRAW);
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[iCircularSurf]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, numCircularElts * sizeof(unsigned int), circularElements, GL_STATIC_DRAW);
    
    delete[] circularVerts;
    delete[] circularElements;
}

